-- The webhook to report violations to.
local WebhookUrl = "https://discordapp.com/api/webhooks/294597321994403851/G-NfaAytd881x97La7D6MejcTtHu4Ux-tQOKWg75oPuoaCmN06xyFM83tA8-sMQyvrGv"

-- Allow four violations within a 60 second period before kicking the player
local MaximumViolations = 4
local ViolationExpirationTime = 60

-- Allow a maximum teleportation distance of 100 studs
local MaximumTeleportationEpsilon = 100

-- Only infract one teleport every 1 seconds
local TeleportPeriod = 1

-- How long do teleportation indemnities, from lighthouses and /tp, last?
local TeleportIndemnityPeriod = 1

-- Maximum variance between Y velocity and humanoid jump power
local JumpPowerVariance = 5

-- Maximum variance between running speed and humanoid walk speed
local WalkSpeedVariance = 5

-- How long a player is allowed to move too fast
local WalkSpeedTime = 1

-- The error allowance for hover detection.
local HoverEpsilon = 5

-- How long a player has to stay at (roughly) the same Y level without support to be considered hovering.
local MaximumAllowedHoverTime = 1

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local import = require(game:GetService("ReplicatedStorage"):WaitForChild("Import"))
local RankChecker = import "~/Commands/RankChecker"

-- Players are tracked on a character basis
local characterData = {}
local violations = {}

-- Logs a violation of some form.
-- If a player has more than MaximumViolations active violations they will be kicked.
local function LogViolation(character, violationName, violationMessage)
	local player = Players:GetPlayerFromCharacter(character)
	
	local violationEntry = {
		Player = player;
		Name = violationName;
		Message = violationMessage;
		Tick = tick();
	}
	
	local playerViolations = violations[character]
	
	-- Can happen if a player violates more than one check and gets kicked for it
	if playerViolations ~= nil then
		-- Insert violation
		table.insert(playerViolations, violationEntry)
		print(("Movement violation logged against %s (user ID: %d): %s (%s)"):format(player.Name, player.UserId, violationName, violationMessage))
		
		-- If they've violated things too many times in a certain timeframe, kick them
		if #playerViolations > MaximumViolations then
--			player:Kick("Too many wrong movements detected!")
--			print(("Kicked %s (user ID: %d): %d wrong movements"):format(player.Name, player.UserId, #playerViolations))
			
			local contentLines = { ("%s (user ID: %d): %d wrong movements"):format(player.Name, player.UserId, #playerViolations) }
			for _, violation in ipairs(playerViolations) do
				table.insert(contentLines, ("%s: %s"):format(violation.Name, violation.Message))
			end
			
			-- Clear out violations so the report is only sent once
			violations[character] = {}
			
			local data = {
				content = table.concat(contentLines, "\n\t")
			}
			
			local success, message = pcall(HttpService.PostAsync, HttpService, WebhookUrl, HttpService:JSONEncode(data))
			if not success then
				warn(message)
			end
		else
			-- Expire after a while
			delay(ViolationExpirationTime, function()
				-- Loop backwards through the array so nothing weird happens
				for i = #playerViolations, 1, -1 do
					-- Remove this specific violation entry
					if playerViolations[i] == violationEntry then
						table.remove(playerViolations, i)
						break
					end
				end
			end)
		end
	end
end

local function CheckWalkSpeed(data, delta)
	local humanoid = data.Humanoid
	local root = data.Root
	
	-- Only running if the state is, well, running.
	if humanoid:GetState() == Enum.HumanoidStateType.Running or humanoid:GetState() == Enum.HumanoidStateType.RunningNoPhysics then
		local maximumSpeed = humanoid.WalkSpeed
		-- Horizontal velocity only; no vertical component
		local speed = math.sqrt(root.Velocity.X ^ 2 + root.Velocity.Z ^ 2)
		
		-- Moving too fast
		if speed - maximumSpeed > WalkSpeedVariance then
			-- Start the clock if it hasn't been started already
			if data.LastOverspeed == nil then
				data.LastOverspeed = tick()
			end
			
			-- Have they been moving too fast for too long?
			if tick() - data.LastOverspeed > WalkSpeedTime then
				-- Log the violation
				LogViolation(data.Character, "WalkSpeed", ("WalkSpeed: %f; Velocity: %f"):format(maximumSpeed, speed))
				
				root.Velocity = Vector3.new(0, root.Velocity.Y, 0)
				
				-- Restart the clock so they can be infracted again in a little bit if they keep going
				data.LastOverspeed = tick()
			end
		else
			-- Reset overspeed, because they're no longer moving too fast
			data.LastOverspeed = nil
		end
	end
end

local function CheckJumpPower(data, delta)
	local humanoid = data.Humanoid
	local root = data.Root
	local humanoidState = humanoid:GetState()
	
	-- Only jumping (or just jumped) if the state is Jumping or FreeFall
	if humanoidState == Enum.HumanoidStateType.Jumping or humanoidState == Enum.HumanoidStateType.Freefall then
		-- Jump power is outside normal bounds; probably has been modified.
		if root.Velocity.Y > humanoid.JumpPower + JumpPowerVariance then
			if not data.InfractedJump then
				-- Log the violation
				LogViolation(data.Character, "JumpPower", ("Power: %f; Velocity: %f"):format(humanoid.JumpPower, root.Velocity.Y))
				
				root.Velocity = Vector3.new(root.Velocity.X, 0, root.Velocity.Z)
				
				-- Make sure we don't infract them multiple times
				data.InfractedJump = true
			end
		else
			-- They're not violating the jump restrictions anymore; reset the jump infraction
			data.InfractedJump = false
		end
	end
end

local function CheckTeleports(data, delta)
	local lastPosition = data.LastPosition
	local currentPosition = data.Root.Position
	local distanceBetween = (currentPosition - lastPosition).magnitude
	local character = data.Character
	
	-- Update their position so they only get infracted once per teleport
	data.LastPosition = currentPosition
	
	-- If the distance is within their walkspeed for this time, then
	-- we can't know if it was a teleport or not.
	local isWithinWalkSpeed = (distanceBetween / delta) <= math.sqrt((data.Humanoid.WalkSpeed + WalkSpeedVariance) ^ 2 + (data.Humanoid.JumpPower + JumpPowerVariance) ^ 2)
	
	-- Not within walk speed: Teleport
	if not isWithinWalkSpeed then
		-- When was their last teleport?
		-- This stops a single teleport from counting as multiple.
		if tick() - data.LastTeleport >= TeleportPeriod then
			-- Have they been indemnified?
			if tick() - data.TeleportAllowance <= TeleportIndemnityPeriod then
				-- Reset the indemnity
				data.TeleportAllowance = 0
			elseif distanceBetween > MaximumTeleportationEpsilon then
				-- Log the violation.
				LogViolation(character, "Teleport", ("%s to %s; %d studs"):format(tostring(lastPosition), tostring(currentPosition), distanceBetween))
				
				character:MoveTo(lastPosition)
				data.LastPosition = lastPosition
				
				-- Record the last teleportation time
				data.LastTeleport = tick()
			end
		end
	end
end

local function CheckHovering(data, delta)
	local humanoid = data.Humanoid
	local root = data.Root
	
	-- Check the region beneath the player for parts
	local region = Region3.new(root.Position + Vector3.new(-2, -5, -2), root.Position + Vector3.new(2, 0, 2))
	local parts = workspace:FindPartsInRegion3(region, humanoid.Parent)
	
	-- If there are any collideable parts at all in the region beneath the player they could be standing on the ground
	for _, part in ipairs(parts) do
		if part.CanCollide then
			data.Hovering = false
			return
		end
	end
	
	-- If the player's not hovering at this point, or they've exceeded the hover epsilon, reset the hover data
	if not data.Hovering or math.abs(data.HoverHeight - root.Position.Y) > HoverEpsilon then
		data.Hovering = true
		data.HoverHeight = root.Position.Y
		data.HoverStart = tick()
	-- If they're still hovering, and haven't gone outside the hover error margin, they should be infracted.
	elseif tick() - data.HoverStart > MaximumAllowedHoverTime then
		LogViolation(data.Character, "Hover", ("Altitude %d"):format(data.HoverHeight))
		
		-- Reset the hover start value so they don't get infracted every heartbeat
		data.HoverStart = tick()
	end
end

local function OnCharacterAdded(character)
	-- UGLY HACK
	-- Roblox characters aren't positioned properly the tick they're created
	-- No matter where they actually spawn, when they're created they're at (0, 18, 0)
	-- They're then moved
	-- This would cause everyone to rack up a teleportation violation of >200 studs
	-- Wait a tick to allow them to be moved to their proper location before initializing data
	wait(0)
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	local root = character:FindFirstChild("HumanoidRootPart")
	
	local data = {}
	data.Humanoid = humanoid
	data.Root = root
	data.LastPosition = data.Root.Position
	data.LastChecked = tick()
	data.LastTeleport = 0
	data.TeleportAllowance = 0
	data.Player = Players:GetPlayerFromCharacter(character)
	data.Character = character
	
	-- Nuke humanoid data after death so nothing weird happens
	humanoid.Died:Connect(function()
		characterData[character] = nil
		violations[character] = nil
	end)

	characterData[character] = data
	violations[character] = {}
end

local function OnPlayerAdded(player)
	-- Don't even set up the system for staff.
	if RankChecker.IsStaff(player) then return end

	-- If their character's already spawned then set that up
	if player.Character ~= nil then
		OnCharacterAdded(player.Character)
	end
	
	player.CharacterAdded:Connect(OnCharacterAdded)
end

local function OnPlayerRemoving(player)
	for character, violations in pairs(violations) do
		if Players:GetPlayerFromCharacter(character) == nil then
			violations[character] = nil
		end
	end
end

for _, player in ipairs(Players:GetPlayers()) do
	OnPlayerAdded(player)
end

Players.PlayerAdded:Connect(OnPlayerAdded)

-- possibly overkill
RunService.Heartbeat:Connect(function(delta)
	for character, data in pairs(characterData) do
		local root = data.Root
		local humanoid = data.Humanoid
		local player = Players:GetPlayerFromCharacter(character)
		
		CheckWalkSpeed(data, delta)
		CheckJumpPower(data, delta)
		CheckTeleports(data, delta)
--		CheckHovering(data, delta)
	end
end)

script.IndemnifyTeleport.Event:Connect(function(character)
	local data = characterData[character]
	
	if data ~= nil then
		data.TeleportAllowance = tick()
	end
end)
